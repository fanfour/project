{
    "collab_server" : "",
    "contents" : "rm(list = ls())\ngc()\nlibrary(\"parallelMap\")\nlibrary(mlr)\nlibrary(sqldf)\nset.seed(42)\noptions(scipen = 999)\n\n# Installations necessary?\n# \n#   install.packages(\"penalized\")\n#   install.packages(\"C50\")\n#   install.packages(\"randomForest\")\n#   install.packages(\"adabag\")\n\n\n\n#DATA IMPORT AND PREPARATION\noriginalDataImport = function(){\n  \n  train_org = read.csv2(\"joined_train_org_sample.csv\")\n  names(train_org)[names(train_org)==\"revenue\"] = \"revenue_Clean\"\n  \n  #Remove false predictors\n  train_org = subset(train_org, select = -c(X, pid, lineID))\n  \n  #factor data\n  train_org.factor = c(\"adFlag\", \"availability\", \"manufacturer\", \"group\", \"content\", \"unit\", \n                       \"genericProduct\", \"salesIndex\", \"category\", \"campaignIndex\")\n  \n  for(i in train_org.factor){\n    train_org[i] = as.factor(train_org[[i]])\n  }\n  \n  return(train_org)\n}\nprepDataImport = function(){\n  train = read.csv(\"mergedTrain_sample.csv\")\n  \n  names(train)[names(train)==\"order_Clean\"] = \"order\"\n  names(train)[names(train)==\"price_Clean\"] = \"price\"\n  \n  #Remove false predictors\n  train = subset(train, select = -c(X, pid_Clean, lineID))\n  \n  #WEEKDAYS ARE MISSING\n  train.factor_fix = c(\"adFlag_Clean\", \"availability_Clean\", \"pharmForm_Clean\", \n                       \"genericProduct_Clean\", \"salesIndex_Clean\", \"missingCompetitorPrice\", \"weekdays\")\n  \n  train.factor_rem = c(\"manufacturer_Clean\", \"group_Clean\", \"content_Clean\", \"unit_Clean\", \"category_Clean\", \"campaignIndex_Clean\")\n  \n  train.factor = c(train.factor_fix, train.factor_rem)\n  \n  for(i in train.factor){\n    train[i] = as.factor(train[[i]])\n  }\n  \n  return(train)\n}\nsets = list(originalDataImport(), prepDataImport())\n\nremoveIDLikeFactors = function(listSets, maxNrFactors){\n  #Remove all factorial attributes with nr(factors) > 50\n  for(i in c(1:length(listSets))){\n    test = colnames(listSets[[i]][, sapply(listSets[[i]], is.factor)])\n    \n    rem = c(NULL)\n    for(j in test){\n      if(length(table(listSets[[i]][j])) > maxNrFactors)\n        rem = c(rem, j)\n    }\n    \n    listSets[[i]] = listSets[[i]][, (! colnames(listSets[[i]]) %in% rem)]\n  }\n  \n  \n  return(listSets)\n}\nsets = removeIDLikeFactors(sets, 50)\n\n#MODEL PREPARATION\nrdesc = makeResampleDesc(\"CV\", iters = 3)\n\n\n#learner selection\nlearners = list(makeLearner(\"classif.OneR\"))\n\n#makeFeatSelWrapper(\"classif.C50\", resampling = rdesc, control = makeFeatSelControlGA(maxit = 10, mutation.rate = 0.1))\n\nreg_learners = list(makeLearner(\"regr.lm\"))\n\n\n#make tasks\nmakeClassifTasks = function(listSets, target, rem = NULL){\n  tasks = list()\n  \n  for(i in c(1:length(listSets))){\n    tasks = append(tasks, list(makeClassifTask(id = as.character(i), data = subset(listSets[[i]], select = -c(quantity, revenue_Clean)), target = target)))\n  }\n  \n  return(tasks)\n}\nmakeRegrTasks = function(listSets, target){\n  regTasks = list()\n  \n  for(i in c(1:length(listSets))){\n\n    #REGRESION OVER QUANTITY\n    newTask = makeRegrTask(id = as.character(i), data = createDummyFeatures(subset(listSets[[i]], select = -c(order, revenue_Clean))), target = target)\n    regTasks = append(regTasks, list(newTask))\n  }\n  \n  return(regTasks)\n}\n\ntraining_and_predicting = function(sets, learnerClass, learnerRegr, TrainTestRatio){\n  #Remove quantity for prediction\n  class_tasks = makeClassifTasks(sets, \"order\")\n  \n  \n  list_pred = list()\n  for(i in c(1:length(class_tasks))){\n    #Get the train set\n    n = length(sets[[i]][[1]])\n    train_class = head(c(1:n), TrainTestRatio*n)\n    test_class = tail(c(1:n), (1-TrainTestRatio)*n)\n\n    \n    for(j in learnerClass){\n     model = train(j, class_tasks[[i]], subset = train_class)\n     predictions = predict(model, class_tasks[[i]], subset = test_class)\n     \n     pred_sum = data.frame(class_pred = (as.numeric(predictions$data$response)-1))\n     pred_sum[\"id\"] = predictions$data$id\n     pred_sum[\"classifier\"] = j$ID\n     pred_sum[\"Task\"] = i\n     pred_sum[\"price\"] = head(sets[[i]]$price, (1-TrainTestRatio)*n)\n     pred_sum[\"revenue_Clean\"] = head(sets[[i]]$revenue_Clean, (1-TrainTestRatio)*n)\n     list_pred = append(list_pred, list(pred_sum))\n    }\n  }\n\n  \n  regTasks = makeRegrTasks(sets, \"quantity\")\n  \n  list_pred_reg = list()\n  for(i in c(1:length(regTasks))){\n    \n    train_reg = as.numeric(rownames(head(sets[[i]][which(sets[[i]]$quantity > 0),], TrainTestRatio*n)))\n    test_reg = as.numeric(tail(rownames(sets[[i]]), (1-TrainTestRatio)*n))\n    \n    \n    for(j in learnerRegr){\n      model = train(j, regTasks[[i]], subset = train_reg)\n      predictions = predict(model, regTasks[[i]], subset = test_reg)\n      \n      pred_sum = data.frame(reg_pred = predictions$data$response)\n      pred_sum[\"id\"] = predictions$data$id\n      pred_sum[\"regression_alg\"] = j$ID\n      list_pred_reg = append(list_pred_reg, list(pred_sum))\n    }\n  }\n  \n  #combine the results\n  final_results = list()\n\n  for(i in c(1:length(list_pred))){\n    final_results = append(final_results, list(merge(list_pred[[i]], list_pred_reg[[i]], by = \"id\")))\n  }\n  \n  return(final_results)\n}\n\n#TRAINING AND PREDICTING ALL\n#parallelStartBatchJobs()\nparallelStartSocket(2, level = \"mlr.resample\")\nfinal_res = training_and_predicting(sets, learners, reg_learners, 0.3)\nparallelStop()\n\n\n\n#FINAL PERFORMANCE EVALUATION\nrevenue_calculation = function(comb_preds){\n  ret = list()\n  for(i in comb_preds){\n    tmp = i\n    tmp[\"revenuePrediction\"] = tmp$class_pred*tmp$reg_pred*tmp$price\n    ret = append(ret, list(tmp))\n  }\n  \n  return(ret)\n}\nrev_preds = revenue_calculation(final_res)\n\nsummary(rev_preds[[2]]$revenuePrediction)\n\n\nresult_viz = function(rev_preds){\n  par(mfrow=c(length(rev_preds),1))\n  \n  for(i in rev_preds){\n    test = i[order(i$revenue_Clean),]\n    plt = plot(c(1:length(test[[1]])), test$revenue_Clean, type = \"l\")\n    print(plt)\n    ln = lines(c(1:length(test[[1]])), test$revenuePrediction, col = \"red\")\n    print(ln)\n  }\n}\n\nresult_viz(rev_preds)\n\nrmse_own = function(actual, predicted){\n    error <- actual - predicted\n    rmse = sqrt(mean(error^2))\n    \n    return(rmse)\n}\nfor(i in rev_preds){\n  print(rmse_own(i$revenue_Clean, i$revenuePrediction))\n}",
    "created" : 1494165612915.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2181714507",
    "id" : "16830E59",
    "lastKnownWriteTime" : 1494165589,
    "last_content_update" : 1494165589,
    "path" : "~/Studium/SS17/DMC17/git/DMC/refactored_final.R",
    "project_path" : "refactored_final.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}